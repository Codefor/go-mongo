// Copyright 2010 Gary Burd
//
// Licensed under the Apache License, Version 2.0 (the "License"): you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package mongo

import (
	"bytes"
	"testing"
	"reflect"
)

type encodeTest struct {
	ptr  interface{} // nil if test will not round-trip
	doc  interface{}
	data []byte
}

type MapSI map[string]interface{}

type T1 struct {
	Test string
}

type T2 struct {
	Mike int
}

var encodeTests = []encodeTest{
	{new(MapSI), MapSI{}, []byte{
		0x05, 0x00, 0x00, 0x00, 0x00}},
	{new(MapSI), MapSI{"test": "hello world"}, []byte{
		0x1B, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x73, 0x74, 0x00, 0x0C, 0x00, 0x00,
		0x00, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00,
		0x00}},
	{new(T1), T1{"hello world"}, []byte{
		0x1B, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x73, 0x74, 0x00, 0x0C, 0x00, 0x00,
		0x00, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00,
		0x00}},
	{new(MapSI), MapSI{"mike": int32(100)}, []byte{
		0x0F, 0x00, 0x00, 0x00, 0x10, 0x6D, 0x69, 0x6B, 0x65, 0x00, 0x64, 0x00, 0x00,
		0x00, 0x00}},
	{new(T2), T2{100}, []byte{
		0x0F, 0x00, 0x00, 0x00, 0x10, 0x6D, 0x69, 0x6B, 0x65, 0x00, 0x64, 0x00, 0x00,
		0x00, 0x00}},
	{new(MapSI), MapSI{"hello": float64(1.5)}, []byte{
		0x14, 0x00, 0x00, 0x00, 0x01, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xF8, 0x3F, 0x00}},
	{new(MapSI), MapSI{"true": true}, []byte{
		0x0C, 0x00, 0x00, 0x00, 0x08, 0x74, 0x72, 0x75, 0x65, 0x00, 0x01, 0x00}},
	{new(MapSI), MapSI{"false": false}, []byte{
		0x0D, 0x00, 0x00, 0x00, 0x08, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x00, 0x00,
		0x00}},
	{new(MapSI), MapSI{"empty": []interface{}{}}, []byte{
		0x11, 0x00, 0x00, 0x00, 0x04, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x00, 0x05, 0x00,
		0x00, 0x00, 0x00, 0x00}},
	{new(MapSI), MapSI{"empty": [...]interface{}{}}, []byte{
		0x11, 0x00, 0x00, 0x00, 0x04, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x00, 0x05, 0x00,
		0x00, 0x00, 0x00, 0x00}},
	{new(MapSI), MapSI{"none": map[string]interface{}{}}, []byte{
		0x10, 0x00, 0x00, 0x00, 0x03, 0x6E, 0x6F, 0x6E, 0x65, 0x00, 0x05, 0x00, 0x00,
		0x00, 0x00, 0x00}},
	{nil, MapSI{"none": struct{}{}}, []byte{
		0x10, 0x00, 0x00, 0x00, 0x03, 0x6E, 0x6F, 0x6E, 0x65, 0x00, 0x05, 0x00, 0x00,
		0x00, 0x00, 0x00}},
	{new(MapSI), MapSI{"test": []byte("test")}, []byte{
		0x14, 0x00, 0x00, 0x00, 0x05, 0x74, 0x65, 0x73, 0x74, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00}},
	{new(MapSI), MapSI{"test": nil}, []byte{
		0x0B, 0x00, 0x00, 0x00, 0x0A, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00}},
	{new(MapSI), MapSI{"date": DateTime(1168216211000)}, []byte{
		0x13, 0x00, 0x00, 0x00, 0x09, 0x64, 0x61, 0x74, 0x65, 0x00, 0x38, 0xBE, 0x1C,
		0xFF, 0x0F, 0x01, 0x00, 0x00, 0x00}},
	{new(MapSI), MapSI{"oid": ObjectId{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B}}, []byte{
		0x16, 0x00, 0x00, 0x00, 0x07, 0x6F, 0x69, 0x64, 0x00, 0x00, 0x01, 0x02, 0x03,
		0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x00}},
	{nil, OrderedMap{{"test", "hello world"}}, []byte{
		0x1B, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x73, 0x74, 0x00, 0x0C, 0x00, 0x00,
		0x00, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00,
		0x00}},
	{nil, MapSI{"regex": Regexp{"a*b", "i"}}, []byte{
		0x12, 0x00, 0x00, 0x00, 0x0B, 0x72, 0x65, 0x67, 0x65, 0x78, 0x00, 0x61, 0x2A,
		0x62, 0x00, 0x69, 0x00, 0x00}},
	{nil, map[string]interface{}{"$where": CodeWithScope{"test", nil}}, []byte{
		0x1F, 0x00, 0x00, 0x00, 0x0F, 0x24, 0x77, 0x68, 0x65, 0x72, 0x65, 0x00, 0x12,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00, 0x05,
		0x00, 0x00, 0x00, 0x00, 0x00}},
}

func TestEncode(t *testing.T) {
	for i, et := range encodeTests {
		var buf bytes.Buffer
		err := Encode(&buf, et.doc)
		data := buf.Bytes()
		if err != nil {
			t.Errorf("%d: error encoding %s: %s", i, et.doc, err)
		} else if !bytes.Equal(et.data, buf.Bytes()) {
			t.Errorf("%d: doc=%s,\n\texpected %q\n\tactual  %q", i, et.doc, et.data, data)
		}
		if et.ptr == nil {
			continue
		}
		pt := reflect.NewValue(et.ptr).Type().(*reflect.PtrType)
		pv := reflect.MakeZero(pt).(*reflect.PtrValue)
		pv.PointTo(reflect.MakeZero(pt.Elem()))
		err = Decode(et.data, pv.Interface())
		doc := pv.Elem().Interface()
		if err != nil {
			t.Errorf("%d: error decoding %s: %s", i, et.doc, err)
		} else if !reflect.DeepEqual(doc, et.doc) {
			t.Errorf("%d: data=%q,\n\texpected %q\n\tactual  %q", i, et.data, et.doc, doc)
		}
	}
}
